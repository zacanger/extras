## Functions are defined as expressions, not declarations
# No way to immediately invoke a function,
# just define it and then call it instead.
id = fn (x) x
# No need for return statement or braces
add = fn (a, b) a + b
# If using braces, need a return statement
mul = fn (a, b) {
  return a + b
}

# First class functions
reduce = fn (f, xs, init) {
  # If ident ends with !, it's mutable.
  # Mutable variables can only be used in a local
  # function scope, not globally
  acc! = init
  # No C-style loops
  for x in xs {
    acc! = f(x, acc!)
  }
  return acc!
}
append = fn (xs, x) {
  ret! = xs ++ x
  return ret!
}
# TODO: no braces, no return statement,
# the newline here doesn't break that,
# but it might not be clear, so should it
# be kept?
appendIf = fn (f, xs, x)
  if f(x) then append(xs, x) else xs
filter = fn (f, xs) {
  ret! = []
  for x in xs {
    ret! = appendIf(f, xs, x)
  }
  return ret
}
map = fn (f, xs) {
  ret! = []
  for x in xs {
      ret! = append(ret!, f(x))
  }
  return ret!
}
flip = fn (f) fn (a, b) f(b, a)
# TODO: does this satisfy this need?
# Each could also be defined in terms of reduce,
# and return the zero-value (0, "", {}, []), but that
# means we'd have to get rid of mixed-type arrays.
# No need for a separate each/foreach, because
# there's no such thing as a function that only
# performs side effects and doesn't return.
each = flip(map)
# Anonymous inline callbacks work
each([1, 2, 3], fn (x) {
  print x
  return 0
})

# Closures, anonymous functions, partial application
thing = fn (s) {
  return fn (ss) {
    return s + ss
  }
}
# This could also be written as
thing = fn (s) fn (ss) s + ss
# Or
thing = fn (s) {
  return fn (ss) s + ss
}
# Or
thing = fn (s) fn (ss) {
  return s + ss
}
# But the first way is clearer

# Recursion
fib = fn (n) if n <= 1 then 1 else fib(n - 1) + fib(n - 2)

# Void function. Note the !. This indicates
# a function that doesn't return anything. Because there's no
# real concept of undefined or void, assigning to a function call
# from a fn! would be an error. Since this one doesn't do
# anything at all, we just have empty braces (leaving out the
# braces would be a syntax error).
foo = fn! () {}
f = foo() # Error
foo = fn! () # Error
foo = fn! () {
  # do something effectful where a return value isn't important,
  # like writing to stdout.
  system.stdout.write('howdy\n')
}

join = fn (s, xs) reduce(append, xs, s)
# TODO: not sure if this is right; should it be an operator?
mod = fn (a, b) {
  x = a / b
  return a - x * b
}
fizzbuzz = fn (n) {
  ret! = []
  for i in range(0, n) {
    # Block scope, so s is re-initialized on each iteration.
    # If we defined it above the for, it would need to be s!.
    s =
      if mod(n, 3) && mod(n, 5) then 'Fizzbuzz'
      else if mod(n, 3) then 'Fizz'
      else if mod(n, 5) then 'Buzz'
      else "{n}"
      # Mixed type arrays are valid, but we're using a
      # string because we'd get a TypeError when
      # joining if we passed a number.
      ret! = append(ret!, s)
  }
  return join('\n', ret!)
}
# See below for print implementation
print(fizzbuzz(100))

# Variadic functions use the ... operator. Convention is to use the name
# `args`, but it's not enforced.
example = fn (...args) {
  # args is an array
  for arg in args {
    # do stuff
  }
}
# If you want to use named paramaters as well,
# varargs obviously need to come last.
exampleWithOtherArgs = fn (foo, bar, ...args) {}
# Length should work with strings, arrays, and dictionaries
# TODO: This might make more sense to implement in the host language
length = fn (iterable) {
  ret! = 0
  for i in interable {
      ret! = ret! + 1
  }
  return ret!
}
# TODO: This might make more sense to implement in the host language
range = fn (...args) {
  start! = args[0]
  end! = args[1]
  step! = if length(args) == 3 then args[2] else 1
  # TODO: ...
}

# Errors
_error = fn (type) {
  return fn (...args) {
    message = args[0]
    stack = args[1]
    code = if length(args) == 3 then args[2] else 1
    formatted = "{type}: {message}"
    return {
      code: code,
      error: formatted,
      message: message,
      stack: stack,
      type: type,
    }
  }
}
type_error = _error('TypeError')
range_error = _error('RangeError')
syntax_error = _error('SyntaxError')
error = _error('Error')
panic = fn! (err) {
  err = args[0]
  print(err.error)
  # print err.stack if debug level
  exit(err.code)
}
